# 设计类专题

## [LeetCode 341. 扁平化嵌套列表迭代器](https://leetcode-cn.com/problems/flatten-nested-list-iterator/)

**题目描述**

>   给你一个嵌套的整数列表 `nestedList` 。每个元素要么是一个整数，要么是一个列表；该列表的元素也可能是整数或者是其他列表。请你实现一个迭代器将其扁平化，使之能够遍历这个列表中的所有整数。
>
>   实现扁平迭代器类 `NestedIterator` ：
>
>   +   `NestedIterator(List<NestedInteger> nestedList)` 用嵌套列表 `nestedList` 初始化迭代器。
>   +   `int next()` 返回嵌套列表的下一个整数。
>   +   `boolean hasNext()` 如果仍然存在待迭代的整数，返回 `true` ；否则，返回 `false` 。
>       你的代码将会用下述伪代码检测：
>
>   ```c++
>   initialize iterator with nestedList
>   res = []
>   while iterator.hasNext()
>       append iterator.next() to the end of res
>   return res
>   ```
>
>
>   如果 `res` 与预期的扁平化列表匹配，那么你的代码将会被判为正确。

**示例 1**

>   输入：`nestedList = [[1,1],2,[1,1]]`
>   输出：`[1,1,2,1,1]`
>   解释：通过重复调用 `next` 直到 `hasNext` 返回 `false`，`next` 返回的元素的顺序应该是: `[1,1,2,1,1]`。

**示例 2**

>   输入：`nestedList = [1,[4,[6]]]`
>   输出：`[1,4,6]`
>   解释：通过重复调用 `next` 直到 `hasNext` 返回 `false`，`next` 返回的元素的顺序应该是: `[1,4,6]`。

**提示**

>   +   $1 <= nestedList.length <= 500$
>   +   $嵌套列表中的整数值在范围 [-106, 106] 内$

**手写稿**

![331157](img/331157.png)

**代码一：树的遍历【递归写法】**

```c++
/**
 * // This is the interface that allows for creating nested lists.
 * // You should not implement it, or speculate about its implementation
 * class NestedInteger {
 *   public:
 *     // Return true if this NestedInteger holds a single integer, rather than a nested list.
 *     bool isInteger() const;
 *
 *     // Return the single integer that this NestedInteger holds, if it holds a single integer
 *     // The result is undefined if this NestedInteger holds a nested list
 *     int getInteger() const;
 *
 *     // Return the nested list that this NestedInteger holds, if it holds a nested list
 *     // The result is undefined if this NestedInteger holds a single integer
 *     const vector<NestedInteger> &getList() const;
 * };
 */

class NestedIterator {
public:
    vector<int> q;
    int k;
    void dfs(NestedInteger& u) {
        // 如果是叶子结点
        if (u.isInteger()) q.push_back(u.getInteger());
        // 遍历根节点的孩子节点
        else for (auto& u1 : u.getList()) dfs(u1);
        return;
    }
    NestedIterator(vector<NestedInteger> &nestedList) {
        k = 0;
        for (auto& u : nestedList) dfs(u);
    }
    
    int next() {
        return q[k ++];
    }
    
    bool hasNext() {
        return k < q.size();
    }
};

/**
 * Your NestedIterator object will be instantiated and called as such:
 * NestedIterator i(nestedList);
 * while (i.hasNext()) cout << i.next();
 */
```

**代码二：迭代**

```c++
/**
 * // This is the interface that allows for creating nested lists.
 * // You should not implement it, or speculate about its implementation
 * class NestedInteger {
 *   public:
 *     // Return true if this NestedInteger holds a single integer, rather than a nested list.
 *     bool isInteger() const;
 *
 *     // Return the single integer that this NestedInteger holds, if it holds a single integer
 *     // The result is undefined if this NestedInteger holds a nested list
 *     int getInteger() const;
 *
 *     // Return the nested list that this NestedInteger holds, if it holds a nested list
 *     // The result is undefined if this NestedInteger holds a single integer
 *     const vector<NestedInteger> &getList() const;
 * };
 */

class NestedIterator {
public:
    stack<NestedInteger> stk;
    NestedIterator(vector<NestedInteger> &nestedList) {
        for (int i = nestedList.size() - 1; i >= 0; i -- ) 
            stk.push(nestedList[i]);
    }
    
    int next() {
        int k = stk.top().getInteger(); stk.pop();
        return k;
    }
    
    bool hasNext() {
        while (stk.size()) {
            auto cur = stk.top();
            if (cur.isInteger()) return true;
            stk.pop();
            for (int i = cur.getList().size() - 1; i >= 0; i -- ) stk.push(cur.getList()[i]);
        }
        return false;
    }
};

/**
 * Your NestedIterator object will be instantiated and called as such:
 * NestedIterator i(nestedList);
 * while (i.hasNext()) cout << i.next();
 */
```

**标签**

`设计数据结构`、`递归`、`迭代器`

**缝合怪**

[LeetCode 385. 迷你语法分析器](#LeetCode 385. 迷你语法分析器)

## [LeetCode 380. O(1) 时间插入、删除和获取随机元素](https://leetcode-cn.com/problems/insert-delete-getrandom-o1/)

**题目描述**

>   实现 `RandomizedSet` 类：
>
>   +   `RandomizedSet()` 初始化 `RandomizedSet` 对象
>   +   `bool insert(int val)` 当元素 `val` 不存在时，向集合中插入该项，并返回 `true` ；否则，返回 `false` 。
>   +   `bool remove(int val)` 当元素 `val` 存在时，从集合中移除该项，并返回 `true` ；否则，返回 `false` 。
>   +   `int getRandom()` 随机返回现有集合中的一项（测试用例保证调用此方法时集合中至少存在一个元素）。每个元素应该有 相同的概率 被返回。
>
>   你必须实现类的所有函数，并满足每个函数的 平均 时间复杂度为 `O(1)` 。

**示例**

>   输入
>   `["RandomizedSet", "insert", "remove", "insert", "getRandom", "remove", "insert", "getRandom"]
>   [[], [1], [2], [2], [], [1], [2], []]`
>   输出
>   `[null, true, false, true, 2, true, false, 2]`
>
>   解释
>   `RandomizedSet randomizedSet = new RandomizedSet();`
>   `randomizedSet.insert(1);` // 向集合中插入 `1` 。返回 `true` 表示 `1` 被成功地插入。
>   `randomizedSet.remove(2);` // 返回 `false` ，表示集合中不存在 `2` 。
>   `randomizedSet.insert(2);` // 向集合中插入 `2` 。返回 `true` 。集合现在包含 `[1,2]` 。
>   `randomizedSet.getRandom();` // `getRandom` 应随机返回 `1` 或 `2` 。
>   `randomizedSet.remove(1);` // 从集合中移除 `1` ，返回 `true` 。集合现在包含 `[2]` 。
>   `randomizedSet.insert(2);` // `2` 已在集合中，所以返回 `false` 。
>   `randomizedSet.getRandom();` // 由于 `2` 是集合中唯一的数字，`getRandom` 总是返回 `2` 。

**提示**

>   +   $-2^{31} <= val <= 2^{31} - 1$
>   +   $最多调用 insert、remove 和 getRandom 函数 2 * 10^5 次$
>   +   $在调用 getRandom 方法时，数据结构中 至少存在一个 元素。$

**手写稿**

![3171612](img/3171612.png)

**代码**

```c++
class RandomizedSet {
public:
    vector<int> g;
    unordered_map<int, int> hash;
    RandomizedSet() {}
    
    bool insert(int x) {
        if (hash.count(x) == 0) {
            hash[x] = g.size();
            g.push_back(x);
            return true;
        }
        return false;
    }
    
    bool remove(int x) {
        if (hash.count(x)) {
            // 获取当前元素x的下标
            int idx = hash[x];
            // 在哈希表中交换数组中当前元素的下标和最后一个元素的下标
            swap(hash[x], hash[g.back()]);
            // 在数组中交换当前元素和最后一个元素
            swap(g[idx], g.back());
            // 在数组中将最后一个元素删除
            g.pop_back();
            // 在哈希表中将最后一个元素对应的下标删除
            hash.erase(x);
            return true;
        }
        return false;
    }
    
    int getRandom() {
        // 返回随机值即可
        return g[rand() % g.size()];
    }
};

/**
 * Your RandomizedSet object will be instantiated and called as such:
 * RandomizedSet* obj = new RandomizedSet();
 * bool param_1 = obj->insert(val);
 * bool param_2 = obj->remove(val);
 * int param_3 = obj->getRandom();
 */
```

**时间复杂度**

$O(1)$

**空间复杂度**

$O(n)$

**标签**

`哈希表`

**缝合怪**

## [LeetCode 382. 链表随机节点](https://leetcode-cn.com/problems/linked-list-random-node/)

**题目描述**

>   给你一个单链表，随机选择链表的一个节点，并返回相应的节点值。每个节点 被选中的概率一样 。
>
>   实现 `Solution` 类：
>
>   +   `Solution(ListNode head)` 使用整数数组初始化对象。
>   +   `int getRandom()` 从链表中随机选择一个节点并返回该节点的值。链表中所有节点被选中的概率相等。

**示例**

>   输入
>   `["Solution", "getRandom", "getRandom", "getRandom", "getRandom", "getRandom"]
>   [[[1, 2, 3]], [], [], [], [], []]`
>   输出
>   `[null, 1, 3, 2, 2, 3]`
>
>   解释
>   `Solution solution = new Solution([1, 2, 3]);`
>   `solution.getRandom();` // 返回 `1`
>   `solution.getRandom();` // 返回 `3`
>   `solution.getRandom();` // 返回 `2`
>   `solution.getRandom();` // 返回 `2`
>   `solution.getRandom();` // 返回 `3`
>   // `getRandom()` 方法应随机返回 `1`、`2`、`3`中的一个，每个元素被返回的概率相等。

**提示**

>   +   $链表中的节点数在范围 [1, 10^4] 内$
>   +   $-10^4 <= Node.val <= 10^4$
>   +   $至多调用 getRandom 方法 10^4 次$

**进阶**

>   如果链表非常大且长度未知，该怎么处理？
>   你能否在不使用额外空间的情况下解决此问题？

**手写稿**

![3171956](img/3171956.png)

**代码**

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* h;
    Solution(ListNode* head) {
        h = head;
    }
    
    int getRandom() {
        int c = -1, n = 0;
        for (auto p = h; p; p = p -> next) {
            // 元素的个数
            n ++;
            // 随机选择某个元素1/n
            if (rand() % n == 0) c = p -> val;
        }
        return c;
    }
};

/**
 * Your Solution object will be instantiated and called as such:
 * Solution* obj = new Solution(head);
 * int param_1 = obj->getRandom();
 */
```

**时间复杂度**

$O(n)$

**空间复杂度**

$O(1)$

**标签**

`蓄水池抽样算法`

**缝合怪**

## [LeetCode 384. 打乱数组](https://leetcode-cn.com/problems/shuffle-an-array/)

**题目描述**

>   给你一个整数数组 `nums` ，设计算法来打乱一个没有重复元素的数组。打乱后，数组的所有排列应该是 等可能 的。
>
>   实现 `Solution class`:
>
>   +   `Solution(int[] nums)` 使用整数数组 `nums` 初始化对象
>   +   `int[] reset()` 重设数组到它的初始状态并返回
>   +   `int[] shuffle()` 返回数组随机打乱后的结果

**示例 1**

>   输入
>   `["Solution", "shuffle", "reset", "shuffle"]
>   [[[1, 2, 3]], [], [], []]`
>   输出
>   `[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]`
>
>   解释
>   `Solution solution = new Solution([1, 2, 3]);`
>   `solution.shuffle();`    // 打乱数组 `[1,2,3]` 并返回结果。任何 `[1,2,3]`的排列返回的概率应该相同。例如，返回 `[3, 1, 2]`
>   `solution.reset();`      // 重设数组到它的初始状态 `[1, 2, 3]` 。返回 `[1, 2, 3]`
>   `solution.shuffle();`    // 随机返回数组 `[1, 2, 3]` 打乱后的结果。例如，返回 `[1, 3, 2]`

**提示**

>   +   $1 <= nums.length <= 200$
>   +   $-10^6 <= nums[i] <= 10^6$
>   +   $nums 中的所有元素都是 唯一的$
>   +   $最多可以调用 5 * 10^4 次 reset 和 shuffle$

**手写稿**

![3172043](img/3172043.png)

**代码**

```c++
class Solution {
public:
    vector<int> a, b;
    Solution(vector<int>& nums) {
        a = nums;
    }
    
    vector<int> reset() {
        return a;
    }
    
    vector<int> shuffle() {
        b = a;
        int n = a.size();
        for (int i = 0; i < n; i ++ )
            // 交换第i张和第i~n张
            swap(b[i], b[i + rand() % (n - i)]);
        return b;
    }
};

/**
 * Your Solution object will be instantiated and called as such:
 * Solution* obj = new Solution(nums);
 * vector<int> param_1 = obj->reset();
 * vector<int> param_2 = obj->shuffle();
 */
```

**时间复杂度**

$O(n)$

**空间复杂度**

$O(n)$

**标签**

`洗牌算法`

**缝合怪**

