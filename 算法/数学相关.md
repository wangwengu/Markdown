# 数学相关

##  普通数学

### [LeetCode 223. 矩形面积](https://leetcode-cn.com/problems/rectangle-area/)

**题目描述**

> 给你 **二维** 平面上两个 **由直线构成且边与坐标轴平行/垂直** 的矩形，请你计算并返回两个矩形覆盖的总面积。
>
> 每个矩形由其 **左下** 顶点和 **右上** 顶点坐标表示：
>
> 第一个矩形由其左下顶点 `(ax1, ay1)` 和右上顶点 `(ax2, ay2)` 定义。
> 第二个矩形由其左下顶点 `(bx1, by1)` 和右上顶点 `(bx2, by2)` 定义。

**示例 1**

![矩形面积 图1](img/%E7%9F%A9%E5%BD%A2%E9%9D%A2%E7%A7%AF%20%E5%9B%BE1.png)

> 输入：`ax1 = -3, ay1 = 0, ax2 = 3, ay2 = 4, bx1 = 0, by1 = -1, bx2 = 9, by2 = 2`
> 输出：`45`

**示例 2**

> 输入：`ax1 = -2, ay1 = -2, ax2 = 2, ay2 = 2, bx1 = -2, by1 = -2, bx2 = 2, by2 = 2`
> 输出：`16`

**提示**

> $-10^4\;<=\;ax1,\;ay1,\;ax2,\;ay2,\;bx1,\;by1,\;bx2,\;by2\;<=\;10^4$

**手写稿**

![矩形面积](img/%E7%9F%A9%E5%BD%A2%E9%9D%A2%E7%A7%AF.png)

**代码**

```c++
class Solution {
public:
    int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) {
        int X = max(0, min(ax2, bx2) - max(ax1, bx1));
        int Y = max(0, min(ay2, by2) - max(ay1, by1));
        return (ax2 - ax1) * (ay2 - ay1) + (bx2 - bx1) * (by2 - by1) - X * Y;
    }
};
```

**标签**

`几何`、`数学`

### [LeetCode 264. 丑数 II](https://leetcode-cn.com/problems/ugly-number-ii/)

**题目描述**

> 给你一个整数 `n` ，请你找出并返回第 `n` 个丑数 。
>
> 丑数 就是只包含质因数 `2、3` 和/或 `5` 的正整数。

**示例 1**

> 输入：`n = 10`
> 输出：`12`
> 解释：`[1, 2, 3, 4, 5, 6, 8, 9, 10, 12]` 是由前 `10` 个丑数组成的序列。

**示例 2**

> 输入：`n = 1`
> 输出：`1`
> 解释：`1` 通常被视为丑数。

**提示**

> $1\;\leq\;n\;\leq\;1690$

**题解**

> 1. 若 `a` 是<font style ="color: red">**丑数**</font>，则 `a * 2` 也是丑数
>
>     + $$
>         若a是丑数，则a可以表示成 \\
>         a = p_1^{n}\;*\;p_2^{m}\;*\;p_3^{k}，\;其中p_1为2，p_2为3，p_3为5 \\
>         现在来看\;a\;*\;p = p_1^{n}\;*\;p_2^{m}\;*\;p_3^{k}\;*\;p，其中p为2，3，或5 \\
>         证毕
>         $$
>
> 2. 三指针做法

**手写稿**

![2172025](img/2172025.png)

**解题步骤**

> 1. 初始丑树数组等于 `q = [1]`，定义三个指针，`i，j，k` 分别对应质因数 `2` 的集合，`3` 的集合，`5` 的集合，初始值为 `i = j = k = 0`
>     + 第一步
>         + `t = min(q[i] * 2, q[j] * 3, q[k] * 5) = min(1 * 2, 1 * 3, 1 * 5) = min(2,  3, 5) = 2`
>         + `t` 取值为 `2`，对应的是 `i` 指针，因此，`i ++`
>         + 此时，`q = [1, 2], i = 1, j = k = 0`
>     + 第二步
>         + `t = min(q[i] * 2, q[j] * 3, q[k] * 5) = min(4, 3, 5) = 3`
>         + `t` 取值为 `3`，对应的是 `j` 指针，因此，`j ++`
>         + 此时，`q = [1, 2, 3], i = 1, j = 1, k = 0`
>     + 第三步
>         + `t = min(q[i] * 2, q[j] * 3, q[k] * 5) = min(4, 6, 5) = 4`
>         + `t` 取值为 `4`，对应的是 `i` 指针，因此，`i ++`
>         + 此时，`q = [1, 2, 3, 4], i = 2, j = 1, k = 0`
>     + 第四步
>         + `t = min(q[i] * 2, q[j] * 3, q[k] * 5) = min(6, 6, 5) = 5`
>         + `t` 取值为 `5`，对应的是 `k` 指针，因此，`k ++`
>         + 此时，`q = [1, 2, 3, 4, 5], i = 2, j = 1, k = 1`
>     + 第五步
>         + `t = min(q[i] * 2, q[j] * 3, q[k] * 5) = min(6, 6, 10) = 6`
>         + `t` 取值为 `6`，对应的是 `i` 和 `j` 指针，因此，`i ++, j ++`
>             + 注意：如果有相等的，指针都需要进行移动，而不能只移动一个指针
>         + 此时，`q = [1, 2, 3, 4, 5, 6], i = 3, j = 2, k = 1`
>     + 依次类推

**代码**

```c++
class Solution {
public:
    int nthUglyNumber(int n) {
        vector<int> q(1, 1);
        for (int i = 0, j = 0, k = 0; q.size() < n; ) {
            int t = min(q[i] * 2, min(q[j] * 3, q[k] * 5));
            q.push_back(t);
            // 不能使用 if else 因为会有相同值
            if (q[i] * 2 == t) i ++;
            if (q[j] * 3 == t) j ++;
            if (q[k] * 5 == t) k ++;
        }
        return q.back();
    }
};
```

**标签**

`三路归并`、`归并排序`

### [AcWing 313. 超级丑数](https://leetcode-cn.com/problems/super-ugly-number/)

**题目描述**

> 超级丑数 是一个正整数，并满足其所有质因数都出现在质数数组 `primes` 中。
>
> 给你一个整数 `n` 和一个整数数组 `primes` ，返回第 `n` 个 超级丑数 。
>
> 题目数据保证第 `n` 个 超级丑数 在 `32-bit` 带符号整数范围内。

**示例 1**

> 输入：`n = 12, primes = [2,7,13,19]`
> 输出：`32`
> 解释：给定长度为 `4` 的质数数组 `primes = [2,7,13,19]`，前 `12` 个超级丑数序列为：`[1,2,4,7,8,13,14,16,19,26,28,32]` 。

**示例 2**

> 输入：`n = 1, primes = [2,3,5]`
> 输出：`1`
> 解释：`1` 不含质因数，因此它的所有质因数都在质数数组 `primes = [2,3,5]` 中。

**提示**

> + $1 <= n <= 10^6$
> + $1 <= primes.length <= 100$
> + $2 <= primes[i] <= 1000$
> + $题目数据 保证 primes[i] 是一个质数$
> + $primes 中的所有值都 互不相同 ，且按 递增顺序 排列$

**解题步骤**

> 1. 同 `LeetCode 264 丑树 II`
>
> 2. 唯一不同的是由 `3` 指针变成 `k` 指针
>
> 3. 具体实现的细节
>
>     ![2180807](img/2180807.png)
>
>     > 1. 三指针有一个寻找最小值的操作 `min(q[i] * 2, min(q[j] * 3, q[k] * 5))`，在本题中，将寻找 `k` 个指针的最小值操作，换成堆（优先队列来实现）
>     > 2. 优先队列中维护两个变量，分别为 `k` 个指针对应的值以及下标
>     > 3. 考虑一个问题，如何确定某个数 `x` 是由哪个质数迭代而来的
>     >     + 对于丑树 $S_p$ 来说，其下一个数为 $k = S_p * p$ ，因此，当前质数 $p = k / S_p$
>     > 4. 如果还是有些许模糊，手动模拟样例即可

**代码**

```c++
class Solution {
public:
    typedef long long LL;
    typedef pair<LL, LL> PLL;
    int nthSuperUglyNumber(int n, vector<int>& primes) {
        // 定义小根堆
        priority_queue<PLL, vector<PLL>, greater<PLL>> heap;
        // 含义在图示手写稿
        for (auto& x : primes) heap.push({x, 1});
        vector<int> q(n + 5);
        q[1] = 1;
        for (int i = 2; i <= n;) {
            auto tp = heap.top(); heap.pop();
            if (tp.first != q[i - 1]) q[i ++ ] = tp.first;
            int idx = tp.second, p = tp.first / q[idx];
            heap.push({(LL)p * q[idx + 1], idx + 1});
        }
        return q[n];
    }
};
```

**标签**

`优先队列`、`K路归并`

### [LeetCode 279. 完全平方数](https://leetcode-cn.com/problems/perfect-squares/)

**题目描述**

> 给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, ...）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。
>
> 给你一个整数 n ，返回和为 n 的完全平方数的 最少数量 。
>
> 完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。

 **示例 1**

> 输入：`n = 12`
> 输出：`3` 
> 解释：`12 = 4 + 4 + 4`

**示例 2**

> 输入：`n = 13`
> 输出：`2`
> 解释：`13 = 4 + 9`

**提示**

> $1 <= n <= 10^4$

**法一:动态规划**

**手写稿**

![完全平方数](img/%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0.png)

**代码**

```c++
class Solution {
public:
    int numSquares(int n) {
        vector<int> f(n + 5, 1e9);
        f[0] = 0;
        for (int i = 1; i <= n; i ++ )
            for (int j = 1; j <= i / j; j ++ )
                f[i] = min(f[i], f[i - j * j] + 1);
        return f[n];
    }
};
```

**方法二:数学**

**步骤**

> 1. [四平方和定理](https://baike.baidu.com/item/%E5%9B%9B%E5%B9%B3%E6%96%B9%E5%92%8C%E5%AE%9A%E7%90%86):每个正整数均可表示为4个整数的平方和,定义此题的上限,答案只能为 `1, 2, 3, 4`
> 2. [勒让德三平方和定理](https://en.wikipedia.org/wiki/Legendre%27s_three-square_theorem):当 $n=4^a(8b+7)$时，`n` 不能写成 `3` 个数的平方和
> 3. 枚举答案是否为 `2`

**代码**

```c++
class Solution {
public:
    bool check(int n) {
        int r = sqrt(n);
        return r * r == n;
    }
    int numSquares(int n) {
        // 判断是否是一个数字
        if (check(n)) return 1;
        // 判断是否是两个数字
        for (int i = 1; i <= n / i; i ++ )
            if (check(n - i * i)) return 2;
        // 判断是否是四个数字
        while (n % 4 == 0) n /= 4;
        if (n % 8 == 7) return 4;
        return 3;
    }
};
```

**标签**

`动态规划`、`数学`

### [LeetCode 233. 数字 1 的个数](https://leetcode-cn.com/problems/number-of-digit-one/)

**题目描述**

> 给定一个整数 `n`，计算所有小于等于 `n` 的非负整数中数字 `1` 出现的个数。

**示例 1**

> 输入：`n = 13`
> 输出：`6`

**示例 2**

> 输入：`n = 0`
> 输出：`0`

**提示**

> + $0 <= n <= 10^9$

**题解**

> 1. 将数字分解成每个数字，存放到 vector 里面，注意顺序问题
> 2. 从前往后依次遍历每个数字，判断当前位置上 1 的个数累加即可

**手写稿**

![WX20220119-100611@2x (1)](img/WX20220119-100611@2x%20(1).png)

**代码**

```c++
class Solution {
public:
    int countDigitOne(int n) {
        vector<int> num;
        while (n) {
            num.push_back(n % 10);
            n /= 10;
        }
        // 注意顺序问题
        reverse(num.begin(), num.end());
        int res = 0;
        for (int i = 0; i < num.size(); i ++ ) {
            int left = 0, right = 0, p = 1;
            for (int j = 0; j < i; j ++ ) left = left * 10 + num[j];
            for (int j = i + 1; j < num.size(); j ++ )
                right = right * 10 + num[j], p *= 10;
            if (num[i] == 0) res += left * p;
            else if (num[i] == 1) res += left * p + right + 1;
            else res += (left + 1) * p;
        }
        return res;
    }
};
```

**标签**

`数学`

### [LeetCode 231. 2 的幂](https://leetcode-cn.com/problems/power-of-two/)

**题目描述**

> 给你一个整数 `n`，请你判断该整数是否是 `2` 的幂次方。如果是，返回 `true` ；否则，返回 `false` 。
>
> 如果存在一个整数 `x`  使得 `n == 2x` ，则认为 `n` 是 `2` 的幂次方。

**示例 1**

> 输入：`n = 1`
> 输出：`true`
> 解释：$2^0 = 1$

**示例 2**

> 输入：`n = 16`
> 输出：`true`
> 解释：$2^4 = 16$

**示例 3**

> 输入：`n = 3`
> 输出：`false`

**示例 4**

> 输入：`n = 4`
> 输出：`true`

**示例 5**

> 输入：`n = 5`
> 输出：`false`

**提示**

> + $-2^{31} <= n <= 2^{31} - 1$

**进阶**

> 你能够不使用循环/递归解决此问题吗？

**方法一：对数**

**代码**

```c++
class Solution {
public:
    bool isPowerOfTwo(int n) {
        if (n <= 0) return false;
        return (log2(n) - int(log2(n))) == 0;
    }
};
```

**方法二：位运算**

**解析**

> 1. 一个数字 `x` 如果是 `2` 的幂，则说明 `x` 的二进制表示为 `000001000000`
> 2. `lowbit` 计算最后一位 `1` 的大小，判断是否和 `x` 相等即可

**代码**

```c++
class Solution {
public:
    bool isPowerOfTwo(int n) {
        if (n <= 0) return false;
        return (n & -n) == n;
    }
};
```

**方法三：取巧的位运算**

**解析**

> 1. 由<a href="https://baike.baidu.com/item/%E7%AE%97%E6%9C%AF%E5%9F%BA%E6%9C%AC%E5%AE%9A%E7%90%86/10920095">算术基本定理</a>可知，任意自然数都可以唯一分解为若干个质数的乘积，数 `x` 若是 `2` 的幂，则 `x` 的质因数只有 `2`，除此之外，不存在其他的质因数
>     + 反证法
>         + 如果 `x` 的质因数除了 `2` 之外，还有质因数 `p`，则 `p` 一定不能被分解，因为 `p` 也是质数
> 2. 找出最大的只含有 `2` 的质因子的数 `x`，不难发现，所有满足质因子只有 `2` 的数均是 `x` 的因子

**代码**

```c++
class Solution {
public:
    bool isPowerOfTwo(int n) {
        if (n <= 0) return false;
        return (1 << 30) % n == 0;
    }
};
```

**标签**

`对数`、`位运算`

### [LeetCode 326. 3 的幂](https://leetcode-cn.com/problems/power-of-three/)

**题目描述**

> 给定一个整数，写一个函数来判断它是否是 `3` 的幂次方。如果是，返回 `true` ；否则，返回 `false` 。
>
> 整数 `n` 是 `3` 的幂次方需满足：存在整数 `x` 使得 `n == 3x`

**示例 1**

> 输入：`n = 27`
> 输出：`true`

**示例 2**

> 输入：`n = 0`
> 输出：`false`

**示例 3**

> 输入：`n = 9`
> 输出：`true`

**示例 4**

> 输入：`n = 45`
> 输出：`false`

**提示**

> + $-2^{31} <= n <= 2^{31} - 1$

**方法一：对数函数**

**公式推导**

> 由于 c++ 没有以任意自然数为底的对数函数，因此，需要使用换底公式进行推导计算，证明如下：
> $$
> 换底公式：log_ab = \frac{log_cb}{log_ca}，其中c为任意自然数 \\
> 当c=10时，有log_ab = \frac{loga}{logb}
> $$

**代码**

```c++
class Solution {
public:
    bool isPowerOfThree(int n) {
        // 不能是负数
        if (n <= 0) return false;
        double x = log10(n) / log10(3);
        return x == int(x);
    }
};
```

**方法二：打表**

**步骤**

> 1. 对于任意一个数 `x` 来说，$3^x$ 可能的取值为 $3^0, 3^1, 3^2, 3^3,..., 3^n,..., 3^{+\infty}$
> 2. 取最大值 $3^n = 3 * 3 ^ {n - 1}$ ，可以看出所有比最大值小的数同时又是 `3` 的幂的数都是最大值的因子，因此，可以找出最大值，然后判断是否是最大值的因子即可
> 3. <font style="color: red">**注意：x必须得是质数，原因：<a href="https://baike.baidu.com/item/%E7%AE%97%E6%9C%AF%E5%9F%BA%E6%9C%AC%E5%AE%9A%E7%90%86/10920095">算术基本定理</a>**</font>，详细解释如下
>     + 由算术基本定理可知，任意<font style="color: red">**自然数**</font>都可以<font style="color: red">**唯一**</font>分解为若干个<font style="color: red">**质数**</font>相乘
>     + 反证法
>         + 如果数 `x` 分解之后的质数除了 `3` 之外，还有别的质数 `p`，则 `x` 一定不是 `3` 的幂，因为 `p` 也是质数，且不能再次分解
>         + 因此，如果数 `x` 是 `3` 的幂，则其质因子有且只有 `3` 才可
> 4. 找出最大的满足质因子只有 `3` 的数 `x`，不难发现，所有满足质因子只有 `3` 的数均是 `x` 的因子

**代码**

```c++
class Solution {
public:
    bool isPowerOfThree(int n) {
        if (n <= 0) return false;
        return 1162261467 % n == 0;
    }
};
```

**标签**

`对数`、`算术基本定理`、`数论`

### [LeetCode 342. 4的幂](https://leetcode-cn.com/problems/power-of-four/)

**题目描述**

> 给定一个整数，写一个函数来判断它是否是 `4` 的幂次方。如果是，返回 `true` ；否则，返回 `false` 。
>
> 整数 `n` 是 `4` 的幂次方需满足：存在整数 `x` 使得 `n == 4x`

**示例 1**

> 输入：`n = 16`
> 输出：`true`

**示例 2**

> 输入：`n = 5`
> 输出：`false`

**示例 3**

> 输入：`n = 1`
> 输出：`true`

**提示**

> + $-2^{31} <= n <= 2{31} - 1$

**进阶**

> 你能不使用循环或者递归来完成本题吗？

**方法一：对数**

**代码**

```c++
class Solution {
public:
    bool isPowerOfFour(int n) {
        if (n <= 0) return false;
        double x = log10(n) / log10(4);
        return x == int(x);
    }
};
```

**方法二：位运算**

**解析**

> 1. 如果数 `x` 是 `4` 的幂，则 `x` 也一定是 `2` 的幂，即有 $4 ^ x = (2 ^ 2)^x = (2 ^ x) ^ 2$
>     + 先对 `x` 进行开方得到 `r`，判断 $r^2$ 是否等于 `x`
>         + 不等于，返回❌
>         + 等于，判断 `r` 是否是 `2` 的幂即可

**代码**

```c++
class Solution {
public:
    bool isPowerOfFour(int n) {
        if (n <= 0) return false;
        int r = sqrt(n);
        if (r * r != n) return false;
        return (1 << 30) % n == 0;
    }
};
```

**标签**

`对数`、`位运算`

### [LeetCode 343. 整数拆分](https://leetcode-cn.com/problems/integer-break/)

**题目描述**

>   给定一个正整数 `n` ，将其拆分为 `k` 个 正整数 的和（ `k >= 2` ），并使这些整数的乘积最大化。
>
>   返回 你可以获得的最大乘积 。

**示例 1**

>   输入: `n = 2`
>   输出: `1`
>   解释: `2 = 1 + 1, 1 × 1 = 1`。

**示例 2**

>   输入: `n = 10`
>   输出: `36`
>   解释: `10 = 3 + 3 + 4, 3 × 3 × 4 = 36`。

**提示**

>   +   $2 <= n <= 58$

**手写稿**

![332159](img/332159.png)

**代码**

```c++
class Solution {
public:
    int integerBreak(int n) {
        if (n <= 3) return 1 * (n - 1);
        int res = 1;
        while (n >= 5) n -= 3, res *= 3;
        return res * n;
    }
};
```

**标签**

`数学`

### [LeetCode 357. 计算各个位数不同的数字个数](https://leetcode-cn.com/problems/count-numbers-with-unique-digits/)

**题目描述**

>   给定一个非负整数 `n`，计算各位数字都不同的数字 `x` 的个数，其中 $0 ≤ x < 10^n$ 。

**示例**

>   输入: `2`
>   输出: `91`
>   解释: 答案应为除去 `11,22,33,44,55,66,77,88,99` 外，在 `[0,100)` 区间内的所有数字。

**手写稿**

![350904](img/350904.png)

**代码**

```c++
class Solution {
public:
    int countNumbersWithUniqueDigits(int n) {
        // 0 ～ 9 共10个数字，n > 10 无意义
        n = min(n, 10);
        vector<int> f(n + 1);
        // 0 特判
        if (n == 0) return 1;
        f[1] = 9;
        for (int i = 2; i <= n; i ++ ) f[i] = f[i - 1] * (11 - i);
        int res = 0;
        for (int i = 1; i <= n; i ++ ) res += f[i];
        // 加上 0 这个数字
        return res + 1;
    }
};
```

**标签**

`排列组合`、`数学`、`动态规划`

## 数论相关

### [AcWing 319. 灯泡开关](https://leetcode-cn.com/problems/bulb-switcher/)

**题目描述**

> 初始时有 `n` 个灯泡处于关闭状态。第一轮，你将会打开所有灯泡。接下来的第二轮，你将会每两个灯泡关闭第二个。
>
> 第三轮，你每三个灯泡就切换第三个灯泡的开关（即，打开变关闭，关闭变打开）。第 `i` 轮，你每 `i` 个灯泡就切换第 `i` 个灯泡的开关。直到第 `n` 轮，你只需要切换最后一个灯泡的开关。
>
> 找出并返回 `n` 轮后有多少个亮着的灯泡。 

**示例 1**

![img](img/bulb.jpg)

> 输入：`n = 3`
> 输出：`1 `
> 解释：
> 初始时, 灯泡状态 [关闭, 关闭, 关闭].
> 第一轮后, 灯泡状态 [开启, 开启, 开启].
> 第二轮后, 灯泡状态 [开启, 关闭, 开启].
> 第三轮后, 灯泡状态 [开启, 关闭, 关闭]. 
>
> 你应该返回 `1`，因为只有一个灯泡还亮着。

**示例 2**

> 输入：`n = 0`
> 输出：`0`

**示例 3**

> 输入：`n = 1`
> 输出：`1`

**提示**

> + $0 <= n <= 10^9$

**手写稿**

![2181929](img/2181929.png)

**代码**

```c++
class Solution {
public:
    int bulbSwitch(int n) {
        // 寻找1～n中完全平方数的个数
        return sqrt(n);
    }
};
```

**标签**

`完全平方数`、`脑筋急转弯`、`数论`

### [LeetCode 365. 水壶问题](https://leetcode-cn.com/problems/water-and-jug-problem/)

>   有两个水壶，容量分别为 `jug1Capacity` 和 `jug2Capacity` 升。水的供应是无限的。确定是否有可能使用这两个壶准确得到 `targetCapacity` 升。
>
>   如果可以得到 `targetCapacity` 升水，最后请用以上水壶中的一或两个来盛放取得的 `targetCapacity` 升水。
>
>   你可以：
>
>   装满任意一个水壶
>   清空任意一个水壶
>   从一个水壶向另外一个水壶倒水，直到装满或者倒空

**示例 1**

>   输入: `jug1Capacity = 3, jug2Capacity = 5, targetCapacity = 4`
>   输出: `true`
>   解释：来自著名的 ["Die Hard"](https://www.youtube.com/watch?v=BVtQNK_ZUJg)

**示例 2**

>   输入: `jug1Capacity = 2, jug2Capacity = 6, targetCapacity = 5`
>   输出: `false`

**示例 3**

>   输入: `jug1Capacity = 1, jug2Capacity = 2, targetCapacity = 3`
>   输出: `true`

**提示**

>   +   $1 <= jug1Capacity, jug2Capacity, targetCapacity <= 10^6$

**手写稿**

![351607](img/351607.png)

**代码**

```c++
class Solution {
public:
    int gcd(int a, int b) {
        if (!b) return a;
        return gcd(b, a % b);
    }
    bool canMeasureWater(int a, int b, int c) {
        if (a + b < c) return false;
        return c % gcd(a, b) == 0; 
    }
};
```

**标签**

`贝祖定理`、`数论`、`欧几里得算法`

## 高斯消元

### [AcWing 883. 高斯消元解线性方程组](https://www.acwing.com/problem/content/885/)

**题目描述**

>   输入一个包含 `n` 个方程 `n` 个未知数的线性方程组。
>
>   方程组中的系数为实数。
>
>   求解这个方程组。
>
>   下图为一个包含 `m` 个方程 `n` 个未知数的线性方程组示例：
>
>   ![9a504fc2d5628535be9dcb5f90ef76c6a7ef634a.gif](img/19_b30080c698-9a504fc2d5628535be9dcb5f90ef76c6a7ef634a.gif)

**输入格式**

>   第一行包含整数 `n`。
>
>   接下来 `n` 行，每行包含 `n + 1` 个实数，表示一个方程的 `n` 个系数以及等号右侧的常数。

**输出格式**

>   如果给定线性方程组存在唯一解，则输出共 `n` 行，其中第 `i` 行输出第 `i` 个未知数的解，结果保留两位小数。
>
>   如果给定线性方程组存在无数解，则输出 `Infinite group solutions`。
>
>   如果给定线性方程组无解，则输出 `No solution`。

**数据范围**

>   +   $1≤n≤100,$
>   +   $所有输入系数以及常数均保留两位小数，绝对值均不超过 100。$

**输入样例**

```c++
3
1.00 2.00 -1.00 -6.00
2.00 1.00 -3.00 -9.00
-1.00 -1.00 2.00 7.00
```

**输出样例**

```c++
1.00
-2.00
3.00
```

**手写稿**

![3201224](img/3201224.jpg)

**代码**

```c++
#include <iostream>
#include <cmath>
using namespace std;
const int N = 110;
const double eps = 1e-6;
int n;
double a[N][N];
int guass() {
    // 化成上三角矩阵
    int r, c;
    // 枚举每一列
    for (r = 1, c = 1; c <= n; c ++ ) {
        // 1. 找主元
        int t = r;
        for (int i = r; i <= n; i ++ )
            if (fabs(a[i][c]) > fabs(a[t][c])) t = i;
        // 如果当前列的最大值已经是0，则不需要再进行2，3，4步骤
        if (fabs(a[t][c]) < eps) continue;
        // 2. 交换两行
        if (t != r) // 如果当前列的最大值所在的行不是本行，则交换两行
            for (int i = c; i <= n + 1; i ++ ) swap(a[r][i], a[t][i]);
        // 3. 归一化
        // 倒序枚举
        for (int i = n + 1; i >= c; i -- ) a[r][i] /= a[r][c];
        // 4. 将当前列的其他值消成0
        for (int i = r + 1; i <= n; i ++ )
            for (int j = n + 1; j >= c; j -- ) {
                // 如果已经是0，则不需要再进行
                if (fabs(a[i][c]) < eps) continue;
                a[i][j] -= a[r][j] * a[i][c];
            }
        r ++;
    }
    if (r <= n)
        for (int i = r; i <= n; i ++ ) {
            if (fabs(a[i][n + 1])) return -1;
        return 0;
    }
    // 化成对角矩阵
    for (int i = n - 1; i >= 1; i -- )
        for (int j = i + 1; j <= n; j ++ )
            a[i][n + 1] -= a[i][j] * a[j][n + 1];
    return 1;
}
int main() {
    scanf("%d", &n);
    for (int i = 1; i <= n; i ++ )
        for (int j = 1; j <= n + 1; j ++ )
            scanf("%lf", &a[i][j]);
    int t = guass();
    if (t == -1) printf("No solution");
    else if (t == 0) printf("Infinite group solutions");
    else
        for (int i = 1; i <= n; i ++ ) {
            if (fabs(a[i][n + 1]) < eps) cout << "0.00" << endl;
            else printf("%.2lf\n", a[i][n + 1]);
        }
    return 0;
}
```

**时间复杂度**

$O(n^3)$

**空间复杂度**

$O(n^2)$

**标签**

`高斯消元`

**缝合怪**

### [AcWing 884. 高斯消元解异或线性方程组](https://www.acwing.com/problem/content/886/)

**题目描述**

>   输入一个包含 `n` 个方程 `n` 个未知数的异或线性方程组。
>
>   方程组中的系数和常数为 `0` 或 `1`，每个未知数的取值也为 `0` 或 `1`。
>
>   求解这个方程组。
>
>   异或线性方程组示例如下：
>
>   ```c++
>   M[1][1]x[1] ^ M[1][2]x[2] ^ … ^ M[1][n]x[n] = B[1]
>   M[2][1]x[1] ^ M[2][2]x[2] ^ … ^ M[2][n]x[n] = B[2]
>   …
>   M[n][1]x[1] ^ M[n][2]x[2] ^ … ^ M[n][n]x[n] = B[n]
>   ```
>
>   其中 `^` 表示异或`(XOR)`，`M[i][j]` 表示第 `i` 个式子中 `x[j]` 的系数，`B[i]` 是第 `i` 个方程右端的常数，取值均为 `0` 或 `1`。

**输入格式**

>   第一行包含整数 `n`。
>
>   接下来 `n` 行，每行包含 `n + 1` 个整数 `0` 或 `1`，表示一个方程的 `n` 个系数以及等号右侧的常数。

**输出格式**

>   如果给定线性方程组存在唯一解，则输出共 `n` 行，其中第 `i` 行输出第 `i` 个未知数的解。
>
>   如果给定线性方程组存在多组解，则输出 `Multiple sets of solutions`。
>
>   如果给定线性方程组无解，则输出 `No solution`。

**数据范围**

>   +   $1≤n≤100$

**输入样例**

```c++
3
1 1 0 1
0 1 1 0
1 0 0 1
```

**输出样例**

```c++
1
0
0
```

**手写稿**

>   1.   同 `AcWing 883. 高斯消元解线性方程组`

**代码**

```c++
#include <iostream>
using namespace std;
const int N = 110;
int n;
int a[N][N];
int guass() {
    int r, c;
    // 转化成上三角矩阵
    for (r = 1, c = 1; c <= n; c ++ ) {
        // 找到当前列绝对值最大的行
        int t = r;
        for (int i = r; i <= n; i ++ )
            if (a[i][c]) {
                t = i;
                break;
            }
        // 如果当前最大值是0，则此行不需要再进行额外的处理
        if (!a[t][c]) continue;
        // 如果当前行不是最大值所在的行，则交换两行
        if (t != r) 
            for (int i = c; i <= n + 1; i ++ ) swap(a[t][i], a[r][i]);
        // 使用当前行去消其它行
        for (int i = r + 1; i <= n; i ++ )
            for (int j = n + 1; j >= c; j -- ) {
                if (a[i][c] == 0) break;
                a[i][j] ^= a[r][j] & a[i][c];
            }
        r ++;
    }
    if (r <= n) {
        for (int i = r; i <= n; i ++ )
            if (a[i][n + 1]) return -1;
        return 0;
    }
    for (int i = n - 1; i >= 1; i -- )
        for (int j = i + 1; j <= n; j ++ ) 
            a[i][n + 1] ^= a[i][j] & a[j][n + 1];
    return 1;
}
int main() {
    scanf("%d", &n);
    for (int i = 1; i <= n; i ++ )
        for (int j = 1; j <= n + 1; j ++ )
            scanf("%d", &a[i][j]);
    int t = guass();
    if (t == -1) puts("No solution");
    else if (t == 0) puts("Multiple sets of solutions");
    else 
        for (int i = 1; i <= n; i ++ ) cout << a[i][n + 1] << endl;
    return 0;
}
```

**时间复杂度**

$O(n^3)$

**空间复杂度**

$O(n^2)$

**标签**

`高斯消元`

**缝合怪**

### [AcWing 207. 球形空间产生器](https://www.acwing.com/problem/content/209/)

**问题描述**

>   有一个球形空间产生器能够在 `n` 维空间中产生一个坚硬的球体。
>
>   现在，你被困在了这个 `n` 维球体中，你只知道球面上 `n + 1` 个点的坐标，你需要以最快的速度确定这个 `n` 维球体的球心坐标，以便于摧毁这个球形空间产生器。
>
>   **注意：** 数据保证有唯一解。

**输入格式**

>   第一行是一个整数 `n`。
>
>   接下来的 `n + 1` 行，每行有 `n` 个实数，表示球面上一点的 `n` 维坐标。
>
>   每一个实数精确到小数点后 `6` 位，且其绝对值都不超过 `20000`。

**输出格式**

>   有且只有一行，依次给出球心的 `n` 维坐标（`n` 个实数），两个实数之间用一个空格隔开。
>
>   每个实数精确到小数点后 `3` 位。

**数据范围**

>   +   $1≤n≤10$

**输入样例**

```c++
2
0.0 0.0
-1.0 1.0
1.0 0.0
```

**输出样例**

```c++
0.500 1.500
```

**手写稿**

![3201626](img/3201626.png)

**代码**

```c++
#include <iostream>
#include <cmath>
using namespace std;
const int N = 15;
const double eps = 1e-6;
int n;
double a[N][N], b[N][N];
// 高斯消元模板
void guass() {
    int r, c;
    for (r = 1, c = 1; c <= n; c ++ ) {
        int t = r;
        for (int i = r; i <= n; i ++ )
            if (fabs(b[i][c]) > fabs(b[t][c])) t = i;
        if (fabs(b[t][c]) < eps) continue;
        if (t != r)
            for (int i = c; i <= n + 1; i ++ ) swap(b[t][i], b[r][i]);
        for (int i = n + 1; i >= c; i -- )
            b[r][i] /= b[r][c];
        for (int i = r + 1; i <= n; i ++ )
            for (int j = n + 1; j >= c; j -- ) {
                if (fabs(b[i][c]) < eps) break;
                b[i][j] -= b[r][j] * b[i][c];
            }
        r ++;
    }
    for (int i = n - 1; i >= 1; i -- )
        for (int j = i + 1; j <= n; j ++ )
            b[i][n + 1] -= b[i][j] * b[j][n + 1];
    return;
}
int main() {
    scanf("%d", &n);
    for (int i = 1; i <= n + 1; i ++ )
        for (int j = 1; j <= n; j ++ )
            scanf("%lf", &a[i][j]);
    // 构造b数组
    for (int i = 2; i <= n + 1; i ++ )
        for (int j = 1; j <= n; j ++ ) {
            b[i - 1][j] = 2 * (a[1][j] - a[i][j]);
            b[i - 1][n + 1] += (a[1][j] * a[1][j]) - a[i][j] * a[i][j];
        }
    guass();
    for (int i = 1; i <= n; i ++ )
        printf("%.3lf ", b[i][n + 1]);
    return 0;

```

**时间复杂度**

$O(n^3)$

**空间复杂度**

$O(n^2)$

**标签**

`解方程`、`高斯消元`

**缝合怪**

[AcWing 883. 高斯消元解线性方程组](#AcWing 883. 高斯消元解线性方程组)

## 约瑟夫环

### 原理介绍

![3221150](img/3221150.png)

### [PTA 7-28 猴子选大王](https://pintia.cn/problem-sets/14/problems/808)

**题目描述**

>   一群猴子要选新猴王。新猴王的选择方法是：让 `N `只候选猴子围成一圈，从某位置起顺序编号为 `1~N` 号。从第 `1` 号开始报数，每轮从 `1` 报到 `3`，凡报到 `3` 的猴子即退出圈子，接着又从紧邻的下一只猴子开始同样的报数。如此不断循环，最后剩下的一只猴子就选为猴王。请问是原来第几号猴子当选猴王？

**输入格式**

>   输入在一行中给一个正整数`N（≤1000）`。

**输出格式**

>   在一行中输出当选猴王的编号。

**输入样例**

```c++
11
```

**输出样例**

```c++
7
```

**手写稿**

>   原理已经说明

**代码**

```c++
#include <iostream>
using namespace std;
const int N = 1010;
int n, k = 3;
int f[N][5];
int main() {
    scanf("%d", &n);
    f[1][k] = 0;
    for (int i = 2; i <= n; i ++ )
        f[i][k] = (f[i - 1][k] + k) % i;
    // 计算的是下标，故答案【编号】需要再+1
    cout << f[n][k] + 1 << endl;
    return 0;
}
```

**时间复杂度**

$O(n)$

**空间复杂度**

$O(n)$

**标签**

`约瑟夫环`

**缝合怪**



### [LeetCode 390. 消除游戏](https://leetcode-cn.com/problems/elimination-game/)

**题目描述**

>   列表 `arr` 由在范围 `[1, n]` 中的所有整数组成，并按严格递增排序。请你对 `arr` 应用下述算法：
>
>   从左到右，删除第一个数字，然后每隔一个数字删除一个，直到到达列表末尾。
>   重复上面的步骤，但这次是从右到左。也就是，删除最右侧的数字，然后剩下的数字每隔一个删除一个。
>   不断重复这两步，从左到右和从右到左交替进行，直到只剩下一个数字。
>   给你整数 `n` ，返回 `arr` 最后剩下的数字。

**示例 1**

>   输入：`n = 9`
>   输出：`6`
>   解释：
>   `arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]`
>   `arr = [2, 4, 6, 8]`
>   `arr = [2, 6]`
>   `arr = [6]`

**示例 2**

>   输入：`n = 1`
>   输出：`1`

**提示**

>   +   $1 <= n <= 10^9$

**手写稿**

![3252237](img/3252237.png)

**代码**

```c++
class Solution {
public:
    int lastRemaining(int n) {
        if (n == 1) return 1;
        return 2 * (n / 2 + 1 - lastRemaining(n / 2));
    }
};
```

**时间复杂度**

$O(log_n)$

**空间复杂度**

$O(1)$

**标签**

`约瑟夫环`

**缝合怪**

